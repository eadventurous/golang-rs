//! # EBNF syntax parser and converter

use lang::ebnf::*;
use lex::MetaResult;

#[derive(Debug)]
pub struct Syntax {
    rules: Vec<Rule>,
    autogenerated_names_registry: Vec<String>,
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Rule {
    name: String,
    definitions: DefinitionList,
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DefinitionList(pub Vec<Definition>);

/// Syntactic definitions are separated by one of '|', '/', '!'.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Definition(pub Vec<Primary>);

pub type Alternative = Definition;

/// Syntactic terms are separated by comma ','.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum Primary {
    Optional(DefinitionList),
    Repeated(DefinitionList),
    Grouped(DefinitionList),
    Terminal(String),
    NonTerminal(String),
    Empty,
}

/// To be a little bit more consistent with ISO standard on EBNF.
pub type Term = Primary;
pub type Factor = Primary;

#[derive(Clone, Debug, Eq, PartialEq)]
pub enum Nesting {
    Optional,
    Repeated,
    Grouped,
}

type EbnfTokens<'a> = ::lex::Tokens<'a, EbnfToken<'a>>;

pub struct Parser<'a> {
    /// Source text
    source: &'a str,
    /// Current token.
    t: Option<MetaResult<'a, EbnfToken<'a>>>,
    /// Iterator over tokens stream.
    iter: EbnfTokens<'a>,
}

mod impls {
    use super::*;
    use lex::{ErrorBytes, MetaResult, SimpleErrorBytes, Span, Token, TokenMeta};
    use std::fmt::{self, Display, Formatter};
    use std::ops::{Deref, DerefMut};
    use syn::bnf::non_empties;

    impl Syntax {
        pub fn new() -> Self {
            Self {
                rules: Vec::new(),
                autogenerated_names_registry: Vec::new(),
            }
        }

        pub fn convert_to_bnf(&mut self) {
            while let Some(xyz) = self.find_nesting() {
                let ref nesting = self.extract(xyz).nesting();
                match nesting {
                    Some(Nesting::Repeated) => {
                        self.rule_1(xyz);
                    }
                    Some(Nesting::Optional) => {
                        self.rule_2(xyz);
                    }
                    Some(Nesting::Grouped) => {
                        self.rule_3(xyz);
                    }
                    _ => unreachable!(),
                }
            }
        }

        /// 1. Convert every repetition `{ E }` to a fresh non-terminal `X` and add `X = eps | X ( E )`.
        fn rule_1(&mut self, (x, y, z): (usize, usize, usize)) {
            #![allow(non_snake_case)]
            match self.extract((x, y, z)).nesting() {
                Some(Nesting::Repeated) => {
                    let X_index = self.add_rule();

                    // wait for rust [nll] feature
                    let list = {
                        let mut X = self.rules[X_index].non_terminal();

                        // nesting = { E }
                        let nesting = self.extract_mut((x, y, z));

                        // swap X and { E }
                        ::std::mem::swap(&mut X, nesting);
                        // clean up after swapping pointers
                        let (X, mut E) = (nesting, X.into_inner().unwrap());

                        // X = eps | X E
                        DefinitionList(vec![
                            // eps
                            Definition(vec![Primary::Empty]),
                            // X E
                            Definition({
                                if E.len() == 1 {
                                    // reuse E
                                    let mut def = E.0.into_iter().nth(0).unwrap().0;
                                    def.insert(0, X.clone());
                                    def
                                } else {
                                    let mut def = vec![X.clone()];
                                    def.push(Primary::Grouped(E));
                                    def
                                }
                            }),
                        ])
                    };

                    // add rule X
                    self.rules[X_index].definitions = list;
                }
                _ => unreachable!(),
            }
        }

        /// 2. Convert every option `[ E ]` to a fresh non-terminal `X` and add `X = eps | E`.
        /// (We can convert `X = A [ E ] B` to `X = A E B | A B`.)
        fn rule_2(&mut self, (x, y, z): (usize, usize, usize)) {
            #![allow(non_snake_case)]
            match self.extract((x, y, z)).nesting() {
                Some(Nesting::Optional) => {
                    // Convert `X = A [ E ] B` to `X = A E B | A B`.
                    // Note that definitions list of X may contain other alternatives on both sides of
                    // definition containing optional term. For example:
                    // X = I | A [ E ] B | ( J | K ) | { L }
                    // X = I | A E B | A B | ( J K ) | { L }
                    // In such case, expansion must take care of preserving other context.

                    let rule = &mut self.rules[x];

                    // [ E ]
                    let E_len = rule.definitions[y][z].inner().unwrap().len();

                    // Expand `A [ E ] B` to `A E B`.
                    // Consider cases where E introduces new "alternatives scope" (e.g. E ::= A | B)
                    // as well as where E is defined as single `Definition`.
                    match E_len {
                        // empty optional: `[ ]`
                        0 => {
                            // just remove it
                            rule.definitions[y].remove(z);
                        }
                        // insert alternative with and without E back to the definitions
                        _ => {
                            // without E
                            let E: Primary = rule.definitions[y].remove(z);

                            // with expanded E
                            match E_len {
                                // optional of single list: `[ E ]` or `[ A B { C } ]`
                                1 => {
                                    let inner =
                                        E.into_inner().unwrap().0.into_iter().nth(0).unwrap();
                                    rule.definitions.insert(y, inner);
                                }
                                // multiple alternatives: `[ A | B ]`
                                _ => {
                                    let inners = E.into_inner().unwrap();
                                    rule.definitions.splice(y..y, inners.0);
                                }
                            }
                        }
                    }
                }
                _ => unreachable!(),
            }
        }

        /// 3. Convert every group `( E )` to a fresh non-terminal `X` and add `X = E`.
        fn rule_3(&mut self, (x, y, z): (usize, usize, usize)) {
            #![allow(non_snake_case)]
            match self.extract((x, y, z)).nesting() {
                Some(Nesting::Grouped) => {
                    let X_index = self.add_rule();

                    let mut X = self.rules[X_index].non_terminal();

                    let list = {
                        let nesting = self.extract_mut((x, y, z));
                        ::std::mem::swap(&mut X, nesting);
                        let nesting = X;

                        nesting.into_inner().unwrap()
                    };

                    self.rules[X_index].definitions = list;
                }
                _ => unreachable!(),
            }
        }

        fn extract(&self, (x, y, z): (usize, usize, usize)) -> &Primary {
            &self.rules[x].definitions.0[y].0[z]
        }

        fn extract_mut(&mut self, (x, y, z): (usize, usize, usize)) -> &mut Primary {
            &mut self.rules[x].definitions.0[y].0[z]
        }

        /// # Returns
        ///
        /// Index of newly inserted rule
        fn add_rule(&mut self) -> usize {
            let rule: Rule = Rule::new(self.allocate_new_name(), DefinitionList(vec![]));
            self.rules.push(rule);
            self.rules.len() - 1
        }

        fn allocate_new_name(&mut self) -> &str {
            let name = format!("X-auto-{}", self.autogenerated_names_registry.len());
            self.autogenerated_names_registry.push(name);
            &*self.autogenerated_names_registry.last().unwrap()
        }

        /// # Returns
        ///
        /// Three indices: rule, definition, primary.
        fn find_nesting(&self) -> Option<(usize, usize, usize)> {
            fn f((x, r): (usize, &Rule)) -> Option<(usize, usize, usize)> {
                match r.definitions.find_nested() {
                    Some((y, z)) => Some((x, y, z)),
                    _ => None,
                }
            }
            self.rules.iter().enumerate().filter_map(f).next()
        }
    }

    impl Display for Syntax {
        fn fmt(&self, f: &mut Formatter) -> fmt::Result {
            writeln!(f, "(E)BNF Syntax rules:")?;
            for rule in self.rules.iter() {
                writeln!(f, "{}", rule)?;
            }
            Ok(())
        }
    }

    impl Rule {
        pub fn new(name: &str, definitions: DefinitionList) -> Self {
            Rule {
                name: name.to_owned(),
                definitions,
            }
        }

        pub fn non_terminal(&self) -> Primary {
            Primary::NonTerminal(self.name.clone())
        }

        pub fn tokens(&self) -> Vec<EbnfToken> {
            let mut tokens = vec![EbnfToken::NonTerminal(&self.name), EbnfToken::Operator(Def)];

            tokens.append(&mut self.definitions.tokens());

            tokens
        }
    }

    impl Display for Rule {
        fn fmt(&self, f: &mut Formatter) -> fmt::Result {
            let mut tokens = self.tokens().into_iter();
            write!(f, "{}", tokens.next().unwrap().describe())?;
            for t in tokens {
                write!(f, " {}", t.describe())?;
            }
            Ok(())
        }
    }

    impl DefinitionList {
        pub fn tokens(&self) -> Vec<EbnfToken> {
            let mut tokens = vec![];

            let mut first = true;
            for d in &self.0 {
                if !first {
                    tokens.push(Operator(Alt));
                }
                first = false;

                tokens.append(&mut d.tokens())
            }

            tokens
        }

        /// # Returns
        ///
        /// Index of definition in this `DefinitionList` AND index of `Primary` in that definition.
        pub fn find_nested(&self) -> Option<(usize, usize)> {
            self.0
                .iter()
                .enumerate()
                .filter_map(Self::filter_map)
                .next()
        }

        fn filter_map((y, d): (usize, &Definition)) -> Option<(usize, usize)> {
            match d.find_nested() {
                Some(z) => Some((y, z)),
                None => None,
            }
        }
    }

    impl Deref for DefinitionList {
        type Target = Vec<Definition>;

        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl DerefMut for DefinitionList {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }

    impl Definition {
        pub fn tokens(&self) -> Vec<EbnfToken> {
            let mut tokens = vec![];

            for p in &self.0 {
                tokens.append(&mut p.tokens());
            }

            tokens
        }

        fn find_nested(&self) -> Option<usize> {
            self.0.iter().position(Primary::is_nested)
        }
    }

    impl Deref for Definition {
        type Target = Vec<Primary>;

        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl DerefMut for Definition {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }

    impl Primary {
        pub fn tokens(&self) -> Vec<EbnfToken> {
            let mut tokens = vec![];
            match *self {
                Primary::Optional(ref list) => {
                    tokens.push(Optional(Start));
                    tokens.append(&mut list.tokens());
                    tokens.push(Optional(End));
                }
                Primary::Repeated(ref list) => {
                    tokens.push(Repeat(Start));
                    tokens.append(&mut list.tokens());
                    tokens.push(Repeat(End));
                }
                Primary::Grouped(ref list) => {
                    tokens.push(Group(Start));
                    tokens.append(&mut list.tokens());
                    tokens.push(Group(End));
                }
                Primary::Terminal(ref t) => {
                    tokens.push(Terminal(&t));
                }
                Primary::NonTerminal(ref t) => {
                    tokens.push(NonTerminal(&t));
                }
                Primary::Empty => {}
            }
            tokens
        }
        pub fn is_nested(&self) -> bool {
            self.is_grouped() || self.is_repeated() || self.is_optional()
        }
        pub fn is_grouped(&self) -> bool {
            match self {
                Primary::Grouped(..) => true,
                _ => false,
            }
        }
        pub fn is_repeated(&self) -> bool {
            match self {
                Primary::Repeated(..) => true,
                _ => false,
            }
        }
        pub fn is_optional(&self) -> bool {
            match self {
                Primary::Optional(..) => true,
                _ => false,
            }
        }
        pub fn nesting(&self) -> Option<Nesting> {
            match self {
                Primary::Optional(..) => Some(Nesting::Optional),
                Primary::Repeated(..) => Some(Nesting::Repeated),
                Primary::Grouped(..) => Some(Nesting::Grouped),
                _ => None,
            }
        }
        pub fn into_inner(self) -> Option<DefinitionList> {
            match self {
                Primary::Optional(list) | Primary::Repeated(list) | Primary::Grouped(list) => {
                    Some(list)
                }
                _ => None,
            }
        }
        pub fn inner(&self) -> Option<&DefinitionList> {
            match self {
                Primary::Optional(ref list)
                | Primary::Repeated(ref list)
                | Primary::Grouped(ref list) => Some(list),
                _ => None,
            }
        }
    }

    impl Nesting {
        fn expected(&self) -> &'static str {
            match *self {
                Nesting::Optional => "]",
                Nesting::Repeated => "}",
                Nesting::Grouped => ")",
            }
        }
    }

    impl<'a> Parser<'a> {
        fn new(source: &'a str, iter: EbnfTokens<'a>) -> Self {
            Parser {
                source,
                t: None,
                iter,
            }
        }

        pub fn parse(source: &'a str, filename: &'a str) -> Result<Syntax, ErrorBytes<'a>> {
            let mut syntax = Syntax::new();

            for line in non_empties(source.lines()) {
                let rule = Self::parse_rule(line)
                    .map_err(|e| ErrorBytes::from(e).source(source).filename(filename))?;
                syntax.rules.push(rule);
            }

            Ok(syntax)
        }

        pub fn parse_rule(source: &'a str) -> Result<Rule, SimpleErrorBytes> {
            let iter = make_lexer().tokens(source);
            let mut this = Parser::new(source, iter);

            let name = this.expect_non_terminal()?;
            this.expect_exact(Operator(Def))?;
            let definitions = this.parse_alternatives(None)?;

            Ok(Rule::new(name, definitions))
        }

        fn parse_alternatives(
            &mut self,
            nesting: Option<Nesting>,
        ) -> Result<DefinitionList, SimpleErrorBytes> {
            let mut definitions = vec![];
            let mut def = vec![];

            while let Some(Ok(meta)) = self.next() {
                match meta.token.clone() {
                    Terminal(t) => {
                        let terminal = if t == "" {
                            Primary::Empty
                        } else {
                            Primary::Terminal(t.to_owned())
                        };
                        def.push(terminal);
                    }
                    NonTerminal(t) => {
                        def.push(Primary::NonTerminal(t.to_owned()));
                    }
                    Operator(Alt) => {
                        definitions.push(Definition(def));
                        def = vec![];
                    }
                    Group(Start) => {
                        let list = self.parse_alternatives(Some(Nesting::Grouped))?;
                        def.push(Primary::Grouped(list));
                    }
                    Optional(Start) => {
                        let list = self.parse_alternatives(Some(Nesting::Optional))?;
                        def.push(Primary::Optional(list));
                    }
                    Repeat(Start) => {
                        let list = self.parse_alternatives(Some(Nesting::Repeated))?;
                        def.push(Primary::Repeated(list));
                    }
                    Group(End) if Some(Nesting::Grouped) == nesting => break,
                    Optional(End) if Some(Nesting::Optional) == nesting => break,
                    Repeat(End) if Some(Nesting::Repeated) == nesting => break,
                    Group(End) | Optional(End) | Repeat(End) => {
                        Err(match nesting {
                            Some(ref nesting) => self.error_expected(nesting.expected()),
                            None => self.error_expected(
                                "none of enclosing parenthesis at top level definition",
                            ),
                        })?;
                    }
                    Operator(Def) => {
                        Err(self.error_expected("anything but ::= operator!"))?;
                    }
                }
            }
            definitions.push(Definition(def));
            match (self.current(), nesting) {
                (Some(Err(e)), _) => Err(e.clone().into()),
                (Some(Ok(..)), _) | (None, None) => {
                    // no more tokens nor nesting
                    Ok(DefinitionList(definitions))
                }
                // no more tokens but nested groups left opened.
                (None, Some(ref nesting)) => Err(self.error_expected(nesting.expected())),
            }
        }

        fn current(&self) -> Option<MetaResult<'a, EbnfToken<'a>>> {
            self.t.clone()
        }

        fn next(&mut self) -> Option<MetaResult<'a, EbnfToken<'a>>> {
            let result = self.iter.next();
            self.t = result;
            self.current()
        }

        fn expect_non_terminal(&mut self) -> Result<&'a str, SimpleErrorBytes> {
            match self.next() {
                Some(Ok(TokenMeta {
                    token: NonTerminal(t),
                    ..
                })) => Ok(t),
                _ => Err(self.error_expected("non-terminal.")),
            }
        }

        fn expect_exact(&mut self, tok: EbnfToken<'a>) -> Result<(), SimpleErrorBytes> {
            match self.next() {
                Some(Ok(TokenMeta { token, .. })) if tok == token => Ok(()),
                _ => Err(self.error_expected(tok.descriptor())),
            }
        }

        fn error_expected(&self, expectation: &str) -> SimpleErrorBytes {
            let description = format!("Expected {}.", expectation);
            match self.current() {
                Some(Ok(meta)) => Into::<SimpleErrorBytes>::into(meta.clone()),
                Some(Err(e)) => Into::<SimpleErrorBytes>::into(e.clone()),
                None => {
                    let span = self
                        .current()
                        .clone()
                        .and_then(|x| x.ok())
                        .map(|t| t.span)
                        .or_else(|| Span::over(self.source))
                        .unwrap_or_default();
                    SimpleErrorBytes {
                        span,
                        description: None,
                    }
                }
            }.description(Some(description))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use lex::Error;

    const FILENAME: &str = "<test.bnf>";

    #[test]
    fn test_parse_expectation() {
        let source = r#"??? ::= <A> "B" <C>"#;
        let result = Parser::parse_rule(source);
        assert!(result.is_err());
        // println!("{:?}", result.err().unwrap())
    }

    #[test]
    fn test_parse_empty() {
        let source = " ";
        let res = Parser::parse_rule(source);
        assert!(res.is_err());

        let err = res.err().unwrap();
        let err: Error<_> = err.into();
        let err = err.source(source).filename(FILENAME);
        // println!("AAAAAAA: {:?}", err);
        // println!("AAAAAAA:\n{}", err);
        let _ = err;
    }

    #[test]
    fn test_parse_no_def() {
        let source = "<A> <AC/DC> <EFG> ::= \"123\" ";
        let res = Parser::parse_rule(source);
        assert!(res.is_err());

        let err: Error<_> = res.err().unwrap().into();
        let err = err.source(source).filename(FILENAME);
        // println!("AAA\n{:?}", err);
        // println!("AAA\n{}", err);
        let _ = err;
    }

    #[test]
    fn test_parse_epsilon() {
        let source = "<A> ::= ";
        let res = Parser::parse_rule(source);
        assert!(res.is_ok());

        let rule = res.unwrap();
        assert_eq!("A", rule.name);
        assert_eq!(rule.definitions.0, vec![Definition(vec![])]);
    }

    #[test]
    fn test_parse_simple_product() {
        let source = r#" <A> ::= <B> "C" "#;
        let res = Parser::parse_rule(source);
        assert!(res.is_ok());

        let rule = res.unwrap();
        assert_eq!("A", rule.name);
        assert_eq!(
            rule.definitions.0,
            vec![Definition(vec![
                Primary::NonTerminal("B".into()),
                Primary::Terminal("C".into())
            ])]
        );
    }

    #[test]
    fn test_parse_alternatives() {
        let source = r#" <A> ::= <B> | "#;
        let res = Parser::parse_rule(source);
        assert!(res.is_ok());

        let rule = res.unwrap();
        assert_eq!(rule.name, "A");
        assert_eq!(
            rule.definitions.0,
            vec![
                Definition(vec![Primary::NonTerminal("B".into())]),
                Definition(vec![])
            ]
        );
    }

    #[test]
    fn test_parse_group() {
        let source = r#" <A> ::= <B> ("c" | <D> <E> | "f") | "g" "#;
        let res = Parser::parse_rule(source);
        assert!(res.is_ok());

        let rule = res.unwrap();
        assert_eq!(rule.name, "A");
        assert_eq!(
            rule.definitions.0,
            vec![
                Definition(vec![
                    Primary::NonTerminal("B".into()),
                    Primary::Grouped(DefinitionList(vec![
                        Definition(vec![Primary::Terminal("c".into())]),
                        Definition(vec![
                            Primary::NonTerminal("D".into()),
                            Primary::NonTerminal("E".into())
                        ]),
                        Definition(vec![Primary::Terminal("f".into())])
                    ]))
                ]),
                Definition(vec![Primary::Terminal("g".into())])
            ]
        );
    }

    #[test]
    fn test_parse_group_unclosed() {
        let source = r#" <A> ::= <B> ( "c" | "#;
        let res = Parser::parse_rule(source);
        assert!(res.is_err());

        let source = r#" <A> ::= <B> [ "c" | "#;
        let res = Parser::parse_rule(source);
        assert!(res.is_err());

        let source = r#" <A> ::= <B> { "c" | "#;
        let res = Parser::parse_rule(source);
        assert!(res.is_err());
    }

    #[test]
    fn test_parse_unexpected_close() {
        let source = r#" <A> ::= ) "#;
        let res = Parser::parse_rule(source);
        assert!(res.is_err());
        // println!("EEE {:?}", res);
    }

    #[test]
    fn test_parse_unexpected_close_another() {
        let source = r#" <A> ::= { [ "b" } "#;
        let res = Parser::parse_rule(source);
        assert!(res.is_err());
        // println!("EEE {:?}", res);
    }

    #[test]
    fn test_parse_deep_nesting() {
        let source = r#" <A> ::= { "b" ([<C>] <D> | "e" {"e"} ) } "#;
        let res = Parser::parse_rule(source);
        assert!(res.is_ok());
    }

    /// # Syntax
    #[test]
    fn test_whole_syntax() {
        let source = r#"
            <A> ::= "d" [ <B> ]
            <B> ::= "c" <A> | <D>

            <D> ::= "e" { "f" <A> }
        "#;
        let res = Parser::parse(source, FILENAME);
        assert!(res.is_ok());

        let syntax = res.unwrap();
        assert_eq!(
            syntax.rules,
            vec![
                Rule::new(
                    "A",
                    DefinitionList(vec![Definition(vec![
                        Primary::Terminal("d".into()),
                        Primary::Optional(DefinitionList(vec![Definition(vec![
                            Primary::NonTerminal("B".into())
                        ])]))
                    ])]),
                ),
                Rule::new(
                    "B",
                    DefinitionList(vec![
                        Definition(vec![
                            Primary::Terminal("c".into()),
                            Primary::NonTerminal("A".into())
                        ]),
                        Definition(vec![Primary::NonTerminal("D".into())])
                    ]),
                ),
                Rule::new(
                    "D",
                    DefinitionList(vec![Definition(vec![
                        Primary::Terminal("e".into()),
                        Primary::Repeated(DefinitionList(vec![Definition(vec![
                            Primary::Terminal("f".into()),
                            Primary::NonTerminal("A".into()),
                        ])]))
                    ])]),
                )
            ]
        );
    }
}
